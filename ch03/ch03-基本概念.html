<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body >
<script type="text/javascript">
    //"use strict";
    // 使用++操作符进行的实验
    // 当操作数是string类型时  如果是数值型字符串  则将其转为数值类型再进行++
    // 如果不能转为转为string类型  则返回NaN
    // abcedfghijklmnopqrstuvwxyz
    var str = "123";
    str++;
    console.log(str);
    console.log(typeof str);
    var s1 = "2";
    var s2 = "z";
    var s3 = false;
    var s4 = 1.1;
    var s5 = {
        valueOf : function() {
            return -1;
        }
    }
    s1++;
    s2++;
    s3++;
    s4--;
    s5--;
    console.log(s1);
    console.log(s2);
    console.log(s3);
    console.log(s4);
    console.log(s5);
    var num = -18;
    // 在js中 一般会尽量的隐藏负数转为的补码形式
    // 所以输出的结果是18的原码+负号  即-10010
    console.log(num.toString(2));
    var num1 = 25;
    // 25 - 0000 0000 0000 0000 0000 0000 0001 1001
    //~25 - 1111 1111 1111 1111 1111 1111 1110 0110
    // -1
    //~25 - 1111 1111 1111 1111 1111 1111 1110 0101
    //-26   1000 0000 0000 0000 0000 0000 0001 1010
    // 按非操作的本质  操作数的负值 - 1
    var num2 = ~num1;
    console.log(num2);
    var num3 = 25 & 3;
    // 25 - 0000 0000 0000 0000 0000 0000 0001 1001
    //  3 - 0000 0000 0000 0000 0000 0000 0000 0011
    //                                       1 1011
    console.log(num3);
    var num4 = -64;
    // 64 - 0000 0000 0000 0000 0000 0000 0100 0000
    // 反 - 1111 1111 1111 1111 1111 1111 1011 1111
    // +1 - 1111 1111 1111 1111 1111 1111 1100 0000
    // 右移 1111 1111 1111 1111 1111 1111 1111 1110
    var num5 = num4>>5;
    var num6 = num4>>>5;
    // 右移 0000 0111 1111 1111 1111 1111 1111 1110
    console.log(num5);
    console.log(num6);
    var num7 = false;
    // && 操作符具有短路功能
    var num8 = num7 && sdada;
    console.log(num8);
    num7 = true;
    var num9 = new Object();
    var num11 = new Object();
    var num10 = num7 && num9;
    console.log(num10);
    console.log(num9 && num11);
    console.log(Number.POSITIVE_INFINITY * 2);
    console.log(Number.NEGATIVE_INFINITY);
    console.log(Number.POSITIVE_INFINITY + Number.NEGATIVE_INFINITY);
    console.log("123" * 2);
    console.log(Number.MAX_VALUE);
    console.log(Number.MIN_VALUE);
    console.log(+0);
    console.log(-0);
    var num12 = -0 + -0;
    console.log(num12 == +0);
    var num13 = {
        valueOf : function() {
            return new Object();
        },
        toString : function() {
            return 0;
        }
    };
    var num14 = {
        valueOf : function() {
            return 1;
        },
        toString : function() {
            return 0;
        }
    };
    console.log(num13 + num14);
    console.log("A" < 97);
    console.log("a");
    var num15 = (false == 0);
    console.log(num15);
    console.log(null != undefined);
    var num16 = 55;
    var num17 = "55";
    console.log(num16 == num17);
    console.log(num16 === num17);
    var num18 = (1, 2, 3, 4, 5);
    console.log(num18);
    var num19 = 10;
    while(num19>0) {
        console.log("num19"+num19);
        num19 -- ;
    }
    do {
        console.log("num19="+num19);
    }while(num19>0)
    var i = 0;
    for(;i<10;i++) {
        console.log("i="+i);
    }
    var objs = [
        {
            name : "张三",
            age : 15
        },{
            name : "历史",
            age : 20
        }
    ];
    // for-in 语句用来枚举对象的属性
    for(var obj in objs[0]) {
        console.log(obj);
    }
    //console.log(objs[0].getObj());
    with(location) {
        console.log(search.substring(1));
        console.log(host);
        console.log(href);
    }
    // 在switch语句中  比较的规则是===保证了数据的完整性
    // 所以"55" 和 55 不相等
    var num20 = "55";
    switch(num20) {
        case "55":
            console.log("is string");
            break;
        case 55:
            console.log("is number");
            break;
    }
    // 使用函数
    function sayHi(name, message) {
        console.log("Hello "+ name + ", " + message);
    }
    sayHi("Jack", "Nice to meet you!");
    function sub(num1 ,num2) {
        return num1 > num2 ? num1 - num2 : num2 - num1;
    }
    var result = sub(10, 15);
    console.log(result);
    // ECMAScript 没有函数重载  但是可以模拟函数重载的现象
    // 如果依照类C语言进行的函重载  会造成新定义的同名函数会覆盖之前定义的函数
    function add() {
        var sum = 0;
        for(var i = 0; i< arguments.length; i++) {
            sum += arguments[i];
        }
        console.log(sum);
    }
    add(2, 3);
    add(2);
    add(2, 3, 5);
    // 使用arguments进行参数的计算  如果修改arguments[1]的值  那么num2的值也会对应的修改
    // 但是这种映射关系并不是说argument[1]和num2表示的就是同一个内存区域 相反 他们是两个不同的内存区域  只是会自动映射而已
    // 但是没有为参数num2传递数值的时候  修改arguments[1]的值则不会进行相应的映射
    function doAdd(arg1, arg2) {
        arguments[1] = 10;
        if(arg2 == undefined) {
            console.log(arg1);
        } else {
            console.log(arg1 + arg2);
        }
    }
    doAdd(100);
    var obj = {};
    var obj1 = null;
    console.log(typeof obj);
    console.log(typeof obj1);
</script>
</body>
</html>